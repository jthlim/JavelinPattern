//============================================================================
//
// This provides ARM64 JIT versions of:
//  OnePassPatternProcessor
//  BackTrackingPatternProcessor
//  BitStateBackTrackingPatternProcessor
//
//============================================================================

#include "Javelin/Pattern/Internal/PatternProcessor.h"
#include "Javelin/Pattern/Internal/PatternReverseProcessor.h"

#if PATTERN_USE_JIT && defined(JABI_ARM64_PCS)

#include "Javelin/Assembler/arm64/Assembler.h"
#include "Javelin/Container/EnumSet.h"
#include "Javelin/Pattern/Internal/ArmNeonPatternProcessorsFindMethods.h"

//============================================================================

using namespace Javelin;
using namespace Javelin::PatternInternal;
using namespace Javelin::PatternInternal::ArmNeonFindMethods;

//============================================================================

» .include arm64.jasm

// ARM64 ABI:
// Registers are passed in R0..R7
// Scratch Regsiters: R9..R17
// Platform Register (do not use): R18
// Callee save registers: R19..R28
// Return value R0

» .define p    					x1
» .define pEnd 					x2
» .define captures				reg64{context.captureRegisterIndex}			// Either x3 or x19
» .define pSearchStart			reg64{context.searchStartRegisterIndex}		// Either x4 or x20
» .define pStart				reg64{context.startRegisterIndex}			// Either x5 or x21
» .define isPartialMatch		reg64{context.isPartialMatchRegisterIndex}	// Either x6 or x22
» .define recurseValue			reg64{context.recurseValueRegisterIndex}	// Either x7 or x23
» .define pProgressCheck		reg64{context.progressCheckRegisterIndex}	// Either x8 or x24
» .define pBitState				reg64{context.bitStateRegisterIndex}		// Either x12 or x29

» .macro setSearchStart REG
» .if{context.needsSearchStart}
»   mov pSearchStart, REG
» .endif
» .endm

» .define jumpTableAlignment	64
» .macro markStartOfInstruction PC
» .if{type != PatternProcessorType::BitState
»     && context.hasByteJumpToByteJump
»     && context.byteJumpTargetPcs.Contains(PC)}
»   .unalign jumpTableAlignment
» .endif
»   {PC}:
» .endm

» .macro startSearch TARGET
» .if{context.ShouldDirectBranchToStartingInstruction()}
»   b TARGET
» .else
»   bl TARGET
» .endif
» .endm

» .macro advanceBitStateIfNecessary STEP
» .if{type == PatternProcessorType::BitState}
»    add pBitState, pBitState, #{STEP * context.numberOfBitStateInstructions / 8}
» .endif
» .endm

#define PROGRESS_CHECK_BASE	25

// Progress checks 0-3 stored in x25-x28,
// then pointed to by x24

constexpr size_t MAXIMUM_BITS = 32768;

//============================================================================

namespace
{
	struct AssemblerContext
	{
		bool needsRecurseValue	= false;
		bool needsStart			= false;
		bool needsSearchStart	= false;
		bool hasByteJumpToByteJump = false;
		bool hasExternalFunctionCall = false;
		bool allowPartialMatch;
		int captureRegisterIndex;
		int searchStartRegisterIndex;
		int startRegisterIndex;
		int isPartialMatchRegisterIndex;
		int recurseValueRegisterIndex;
		int progressCheckRegisterIndex;
		int bitStateRegisterIndex;
		int numberOfBitStateInstructions = 0;
		OpenHashSet<uint32_t> byteJumpTargetPcs;
		
		int checkPEndPc = -1;

		Assembler& assembler;
		const PatternData& patternData;
		const ByteCodeHeader *header;
		PatternProcessorType type;

		struct RegistersToSave
		{
			int numberOfRegisters;
			uint8_t registers[12];
		};
		
		RegistersToSave registersToSave;
		
		AssemblerContext(Assembler &aAssembler, const PatternData& aPatternData, const ByteCodeHeader *aHeader, PatternProcessorType aType);
		
		void CheckSufficientData(int pc);

		RegistersToSave GetRegistersToSave() const;
		void EmitProlog(bool partialMatch, bool hasOffset) const;
		void EmitEpilog() const;
		void EmitCallToSearch(int offset, uint64_t searchData, void *searchFunction);
		
		bool ShouldDirectBranchToStartingInstruction() const { return registersToSave.numberOfRegisters == 1 && type != PatternProcessorType::BitState; }
	};
}

AssemblerContext::AssemblerContext(Assembler &aAssembler,
								   const PatternData& aPatternData,
								   const ByteCodeHeader *aHeader,
								   PatternProcessorType aType)
: assembler(aAssembler),
  patternData(aPatternData),
  header(aHeader),
  type(aType)
{
	for(uint32_t pc = 0; pc < header->numberOfInstructions; ++pc)
	{
		ByteCodeInstruction instruction = patternData[pc];
		
		if(!instruction.isSingleReference) ++numberOfBitStateInstructions;
		
		switch(instruction.type)
		{
			case InstructionType::AssertStartOfInput:
			case InstructionType::AssertStartOfLine:
				needsStart = true;
				break;
			case InstructionType::AssertWordBoundary:
			case InstructionType::AssertNotWordBoundary:
				needsStart = true;
				break;
			case InstructionType::AssertStartOfSearch:
				needsSearchStart = true;
				break;
			case InstructionType::AssertRecurseValue:
			case InstructionType::Recurse:
			case InstructionType::ReturnIfRecurseValue:
				needsRecurseValue = true;
				break;
			case InstructionType::ByteJumpTable:
				if(type != PatternProcessorType::BitState)
				{
					const ByteCodeJumpTableData* data = patternData.GetData<ByteCodeJumpTableData>(instruction.data);
					
					if(patternData.HasLookupTableTarget(*data))
					{
						hasByteJumpToByteJump = true;
					}
					
					for(int i = 0; i < data->numberOfTargets; ++i)
					{
						byteJumpTargetPcs.Put(data->pcData[i]);
					}
				}
				break;
			case InstructionType::FindByte:
			case InstructionType::SearchByte:
			case InstructionType::SearchByteEitherOf2:
			case InstructionType::SearchByteEitherOf3:
			case InstructionType::SearchByteEitherOf4:
			case InstructionType::SearchByteEitherOf5:
			case InstructionType::SearchByteEitherOf6:
			case InstructionType::SearchByteEitherOf7:
			case InstructionType::SearchByteEitherOf8:
			case InstructionType::SearchBytePair:
			case InstructionType::SearchBytePair2:
			case InstructionType::SearchBytePair3:
			case InstructionType::SearchBytePair4:
			case InstructionType::SearchByteRange:
			case InstructionType::SearchByteRangePair:
			case InstructionType::SearchByteTriplet:
			case InstructionType::SearchByteTriplet2:
			case InstructionType::SearchBoyerMoore:
			case InstructionType::SearchShiftOr:
				hasExternalFunctionCall = true;
				break;
			case InstructionType::BackReference:
				// Currently calls memcmp
				hasExternalFunctionCall = true;
				break;
			default:
				break;
		}
	}
	
	// Always use round number of bytes.
	numberOfBitStateInstructions = (numberOfBitStateInstructions + 7) & -8;
	
	if(hasExternalFunctionCall)
	{
		captureRegisterIndex = 19;
		searchStartRegisterIndex = 20;
		startRegisterIndex = 21;
		isPartialMatchRegisterIndex = 22;
		recurseValueRegisterIndex = 23;
		progressCheckRegisterIndex = 24;
		bitStateRegisterIndex = 29;
	}
	else
	{
		captureRegisterIndex = 3;
		searchStartRegisterIndex = 4;
		startRegisterIndex = 5;
		isPartialMatchRegisterIndex = 6;
		recurseValueRegisterIndex = 7;
		progressCheckRegisterIndex = 8;
		bitStateRegisterIndex = 12;
	}

	registersToSave = GetRegistersToSave();
}

void AssemblerContext::CheckSufficientData(int pc)
{
	static constexpr EnumSet<InstructionType, uint64_t> COMBINE_PEND_CHECK_INSTRUCTIONS
	{
		InstructionType::AdvanceByte,
		InstructionType::AnyByte,
		InstructionType::Byte,
		InstructionType::ByteEitherOf2,
		InstructionType::ByteEitherOf3,
		InstructionType::ByteRange,
		InstructionType::ByteBitMask,
		InstructionType::ByteNot,
		InstructionType::ByteNotEitherOf2,
		InstructionType::ByteNotEitherOf3,
		InstructionType::ByteNotRange
	};
	
	if(header->IsFixedLength() && header->IsAnchored()) return;
	
	if(pc < checkPEndPc
	   || !COMBINE_PEND_CHECK_INSTRUCTIONS.Contains(patternData[pc].type)) return;
	
	if(patternData[pc].type == InstructionType::AdvanceByte) return;
	
	uint32_t pcEnd = pc+1;
	while(patternData[pcEnd].isSingleReference
		  && COMBINE_PEND_CHECK_INSTRUCTIONS.Contains(patternData[pcEnd].type)) ++pcEnd;
	
	if(pcEnd == pc+1)
	{
		» cmp p, pEnd
		» b.hs *fail
	}
	else
	{
		checkPEndPc = pcEnd;
		» add x0, p, #{pcEnd-pc}
		» cmp x0, pEnd
		» b.hi *fail
	}
}

AssemblerContext::RegistersToSave AssemblerContext::GetRegistersToSave() const
{
	RegistersToSave result = {0};
	
	result.registers[result.numberOfRegisters++] = 30;  // Link register
	
	if(captureRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = captureRegisterIndex;
	}

	if(!header->flags.matchRequiresEndOfInput && isPartialMatchRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = isPartialMatchRegisterIndex;
	}
	if(needsRecurseValue && recurseValueRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = recurseValueRegisterIndex;
	}
	if(needsStart && startRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = startRegisterIndex;
	}
	if(needsSearchStart && searchStartRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = searchStartRegisterIndex;
	}
	
	for(int i = 0; i < Minimum(int(header->numberOfProgressChecks), 4); ++i)
	{
		result.registers[result.numberOfRegisters++] = PROGRESS_CHECK_BASE+i;
	}
	if(header->numberOfProgressChecks > 4 && progressCheckRegisterIndex > 17)
	{
		result.registers[result.numberOfRegisters++] = progressCheckRegisterIndex;
	}
	
	if(type == PatternProcessorType::BitState)
	{
		result.registers[result.numberOfRegisters++] = bitStateRegisterIndex;
	}
	
	return result;
}

void AssemblerContext::EmitProlog(bool partialMatch, bool hasOffset) const
{
	if(!ShouldDirectBranchToStartingInstruction())
	{
		int stackSize = 8*((registersToSave.numberOfRegisters+1) & -2);
		if(header->numberOfProgressChecks > 4)
		{
			stackSize += 8*(((header->numberOfProgressChecks-4) + 1) & -2);
		}

		JASSERT(registersToSave.numberOfRegisters >= 2);
		» stp reg64{registersToSave.registers[0]}, reg64{registersToSave.registers[1]}, [sp, #{-stackSize}]!
		
		for(int i = 2; i < registersToSave.numberOfRegisters-1; i += 2)
		{
			» stp reg64{registersToSave.registers[i]}, reg64{registersToSave.registers[i+1]}, [sp, #{i*8}]
		}
		if(registersToSave.numberOfRegisters & 1)
		{
			» str reg64{registersToSave.registers[registersToSave.numberOfRegisters-1]}, [sp, #{8*registersToSave.numberOfRegisters - 8}]
		}
	}
	
	if(!header->flags.matchRequiresEndOfInput)
	{
		» movz reg64{isPartialMatchRegisterIndex}, #{partialMatch}
	}
	
	if(needsRecurseValue)
	{
		» mov reg64{recurseValueRegisterIndex}, #-1
	}
	
	if(header->numberOfProgressChecks)
	{
		for(int i = 0; i < Minimum(int(header->numberOfProgressChecks), 4); ++i)
		{
			» mov reg32{PROGRESS_CHECK_BASE+i}, #0
		}
		
		if(header->numberOfProgressChecks > 4)
		{
			int progressCheckOffset = 16 + 8*((registersToSave.numberOfRegisters+1) & -2);
			int stackSlots = header->numberOfProgressChecks - 4;
			
			for(int i = 0; i < stackSlots; i += 2)
			{
				» stp wzr, wzr, [sp, #{8*i + progressCheckOffset}]
			}
			» mov reg64{progressCheckRegisterIndex}, sp
		}
	}
	
	if(needsStart)
	{
		» mov reg64{startRegisterIndex}, x1
	}


	if(type == PatternProcessorType::BitState)
	{
		»  sub sp, sp, #4096
		»  mov reg64{bitStateRegisterIndex}, sp

		// Calculate: (length+1) * bitStateBytes
		//            == length * bitStateBytes + bitStateBytes
		
		» mov w10, #{numberOfBitStateInstructions/8}
		if(hasOffset)
		{
			» sub x11, x2, x3
			» madd x11, x11, x10, x10
		}
		else
		{
			»  madd x11, x2, x10, x10
		}
		
		»  add x11, x11, #15
		»  mov x10, sp
		»  lsr x11, x11, #4
		» loop:
		»  stp xzr, xzr, [x10], #16
		»  sub x11, x11, #1
		»  cbnz x11, loop
	}
}

void AssemblerContext::EmitEpilog() const
{
	if(type == PatternProcessorType::BitState)
	{
		» add sp, sp, #4096
	}
	
	if(!ShouldDirectBranchToStartingInstruction())
	{
		int stackSize = 8*((registersToSave.numberOfRegisters+1) & -2);
		if(header->numberOfProgressChecks > 4)
		{
			stackSize += 8*(((header->numberOfProgressChecks-4) + 1) & -2);
		}
		
		JASSERT(registersToSave.numberOfRegisters >= 2);
		if(registersToSave.numberOfRegisters & 1)
		{
			» ldr reg64{registersToSave.registers[registersToSave.numberOfRegisters-1]}, [sp, #{8*registersToSave.numberOfRegisters - 8}]
		}
		
		for(int i = (registersToSave.numberOfRegisters & -2); i > 2;)
		{
			i -= 2;
			» ldp reg64{registersToSave.registers[i]}, reg64{registersToSave.registers[i+1]}, [sp, #{i*8}]
		}
		» ldp reg64{registersToSave.registers[0]}, reg64{registersToSave.registers[1]}, [sp], #{stackSize}
		» ret
	}
}

void AssemblerContext::EmitCallToSearch(int offset, uint64_t searchData, void *searchFunction)
{
	size_t searchFunctionPtr = (size_t) searchFunction;
	
	» add x0, p, #{offset}
	» cmp x0, pEnd
	» b.hs *fail

	if(type == PatternProcessorType::BitState)
	{
		» str p, [sp, #-16]!
	}
	
	» mov64 x1, searchData
	» stp pEnd, lr, [sp, #-16]!
	» .if delta26x4{searchFunctionPtr}
	»   bl {searchFunctionPtr}
	» .else
	»   mov64 x9, searchFunctionPtr
	»   blr x9
	» .endif
	» ldp pEnd, lr, [sp], #16

	if(type == PatternProcessorType::BitState)
	{
		» ldr x10, [sp], #16
	}

	» cbz x0, *fail
	» sub p, x0, #{offset}

	if(type == PatternProcessorType::BitState)
	{
		» sub x0, p, x10
		if(offset != 0)
		{
			» add x0, x0, #{offset}
		}
		
		if(BitUtility::IsPowerOf2(numberOfBitStateInstructions))
		{
			» add reg64{bitStateRegisterIndex}, reg64{bitStateRegisterIndex}, x0, lsl #{__builtin_ctz(numberOfBitStateInstructions/8)}
		}
		else
		{
			» mov x11, #{numberOfBitStateInstructions/8}
			» madd reg64{bitStateRegisterIndex}, x0, x11, reg64{bitStateRegisterIndex}
		}
	}
}

//============================================================================

static PatternProcessor *CreateArm64PatternProcessor(const void* data, size_t length, PatternProcessorType type, int bytesForBitState)
{
	const ByteCodeHeader* header = (const ByteCodeHeader*) data;
	const uint32_t numberOfInstructions = header->numberOfInstructions;
	const PatternData patternData(header->GetForwardProgram());
	const bool useStackGuard = header->flags.useStackGuard && type == PatternProcessorType::BackTracking;
	int bitStateOffset = 0;
	int lastFail = 0;

	Assembler assembler;
	AssemblerContext context(assembler, patternData, header, type);

	void (*DeleteDestructor)(void*) = &SimpleJitMemoryManager::StaticInstanceRelease;

	»   .quad vtbl
	» vtbl:
	»   .quad destructor, {DeleteDestructor}
	»   .quad *fullMatch, *fullMatchWithCaptures
	»   .quad *partialMatch, *partialMatchWithCaptures
	»   .quad *locatePartialMatch, *populateCaptures
	»   .quad provideCaptures
	»   .quad *canUseFullMatchProgram, *canUsePartialMatchProgram
	» destructor:
	»   brk #0										// Should never be called.
	» provideCaptures:
	
	if(type == PatternProcessorType::BackTracking
	   || type == PatternProcessorType::OnePass)
	{
		» *canUseFullMatchProgram:
		» *canUsePartialMatchProgram:
	}
	if(type == PatternProcessorType::BitState
	   && (header->maximumMatchLength+1) * context.numberOfBitStateInstructions <= MAXIMUM_BITS)
	{
		» *canUseFullMatchProgram:
	}
	
	»   mov w0, #1
	»   ret
	
	if(type == PatternProcessorType::BitState)
	{
		// Need: (length+1) * context.numberOfBitStateInstructions <= MAXIMUM_BITS
		int maximumLength = MAXIMUM_BITS / context.numberOfBitStateInstructions - 1;
		if((header->maximumMatchLength+1) * context.numberOfBitStateInstructions > MAXIMUM_BITS)
		{
			» *canUseFullMatchProgram:		// inputLength
		}
		» *canUsePartialMatchProgram:		// inputLength

		if(maximumLength < (1 << 12))
		{
			» cmp w1, #{maximumLength}
			» cset w0, ls
			» ret
		}
		else
		{
			» mov w0, #{maximumLength}
			» cmp w1, w0
			» cset w0, ls
			» ret
		}
	}
	
	» *fullMatch:  									// data, length
	if(header->flags.alwaysRequiresCaptures)
	{
		» brk #0
	}
	else
	{
		context.EmitProlog(false, false);
		» add pEnd, x1, x2
		» mov captures, #0
		» setSearchStart x1
		» startSearch {header->fullMatchStartingInstruction}f
		context.EmitEpilog();
	}

	» *fullMatchWithCaptures:						// data, length, captures
	context.EmitProlog(false, false);
	»   add pEnd, x1, x2
	if(context.captureRegisterIndex != 3)
	{
		» mov captures, x3
	}
	»   setSearchStart x1
	»   startSearch {header->fullMatchStartingInstruction}f
	context.EmitEpilog();

	» *partialMatch:								// data, length, offset
	if(header->flags.alwaysRequiresCaptures)
	{
		» brk #0
	}
	else
	{
		context.EmitProlog(true, true);
		» add pEnd, x1, x2
		» add p, x1, x3
		» mov captures, #0
		» setSearchStart p
		» startSearch {header->partialMatchStartingInstruction}f
		context.EmitEpilog();
	}

	» *partialMatchWithCaptures:					// data, length, offset, captures
	context.EmitProlog(true, true);
	»   add pEnd, x1, x2
	»   add p, x1, x3
	»   mov captures, x4
	»   setSearchStart p
	»   startSearch {header->partialMatchStartingInstruction}f
	context.EmitEpilog();

	» *locatePartialMatch:							// data, length, offset
	»   stp wzr, wzr, [sp, #{-header->numberOfCaptures*16 - 16}]!
	»   str lr, [sp, #{header->numberOfCaptures*16}]
	»   mov x4, sp
	»   bl *partialMatchWithCaptures
	»   ldr lr, [sp, #{header->numberOfCaptures*16}]
	»   cbz x0, noPartialMatch
	»   ldp x0, x1, [sp], #{header->numberOfCaptures*16 + 16}
	»   ret
	» noPartialMatch:
	»   add sp, sp, #{header->numberOfCaptures*16 + 16}
	»   mov x1, xzr
	»   ret

	» *populateCaptures:							// data, length, offset, captures
	context.EmitProlog(true, true);
	»   add pEnd, x1, x2
	»   add p, x1, x3
	»   mov captures, x4
	»   setSearchStart p
	»   startSearch {header->fullMatchStartingInstruction}f
	context.EmitEpilog();

	» markStartOfInstruction TypeData<uint32_t>::Maximum()
	» *fail:
	»   mov w0, #0
	» *done:
	»   ret
	
	for(uint32_t pc = 0; pc < numberOfInstructions; ++pc)
	{
		// Force instructions not to be aligned to differentiate between jump table address and code address
		»  markStartOfInstruction pc
		
		ByteCodeInstruction instruction = patternData[pc];
		if(type == PatternProcessorType::BitState)
		{
			// The maximum conditional jump span (cbz) is ±1MB
			// The maximum conditional bit jump span (tbz/tbnz) is ±32KB
			// If the maximum instruction is ~64 opcodes,
			// then the fail position needs to be updated every 128 instructions at worst.
			if(pc - lastFail >= 128)
			{
				lastFail = pc;
				
				» b 1f
				»  markStartOfInstruction TypeData<uint32_t>::Maximum()
				» *fail:
				»  mov w0, #0
				» *done:
				»  ret
				» 1:
			}
			if(!instruction.isSingleReference)
			{
				» ldrb w0, [pBitState, #{bitStateOffset/8}]
				» tbnz w0, #{bitStateOffset & 7}, *fail
				» orr w0, w0, #{1 << (bitStateOffset & 7)}
				» strb w0, [pBitState, #{bitStateOffset/8}]

				++bitStateOffset;
			}
		}
		else
		{
			// The maximum conditional jump span (cbz) is ±1MB
			// If the maximum instruction is ~64 opcodes,
			// then the fail position needs to be updated every 4096 instructions at worst.
			if(pc - lastFail >= 4096)
			{
				lastFail = pc;

				» b 1f
				»  markStartOfInstruction TypeData<uint32_t>::Maximum()
				» *fail:
				»  mov w0, #0
				» *done:
				»  ret
				» 1:
			}
		}

		context.CheckSufficientData(pc);

		switch(instruction.type)
		{
		case InstructionType::AdvanceByte:
			{
				int step = 1;
				while(patternData[pc+1].type == InstructionType::AdvanceByte
					  && patternData[pc+1].isSingleReference)
				{
					++step;
					++pc;
				}
				» add p, p, #{step}
				» advanceBitStateIfNecessary step
			}
			break;
		case InstructionType::StepBack:
			» sub p, p, #{instruction.data}
			if(type == PatternProcessorType::BitState)
			{
				» sub pBitState, pBitState, #{instruction.data * context.numberOfBitStateInstructions / 8}
			}
			break;
		case InstructionType::AnyByte:
			» add p, p, #1
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::AssertStartOfInput:
			» cmp p, pStart
			» b.ne *fail
			break;
		case InstructionType::AssertEndOfInput:
			» cmp p, pEnd
			» b.ne *fail
			break;
		case InstructionType::AssertWordBoundary:
			// Set x10 = 1 if current position is a word char
			// Set x11 = 1 if previous position is a word char
			»  mov64 x9, PatternProcessorBase::WORD_MASK
			»  mov x10, #0
			»  cmp p, pEnd
			»  b.eq pIsAtEnd
			»  ldrb w0, [p]
			»  ldrb w10, [x9, x0]
			» pIsAtEnd:
			»  mov x11, #0
			»  cmp p, pStart
			»  b.eq pIsAtStart
			»  ldurb w0, [p, #-1]
			»  ldrb w11, [x9, x0]
			» pIsAtStart:
			»  cmp w10, w11
			»  b.eq *fail
			break;
		case InstructionType::AssertNotWordBoundary:
			// Set x10 = 1 if current position is a word char
			// Set x11 = 1 if previous position is a word char
			»  mov64 x9, PatternProcessorBase::WORD_MASK
			»  mov x10, #0
			»  cmp p, pEnd
			»  b.eq pIsAtEnd
			»  ldrb w0, [p]
			»  ldrb w10, [x9, x0]
			» pIsAtEnd:
			»  mov x11, #0
			»  cmp p, pStart
			»  b.eq pIsAtStart
			»  ldurb w0, [p, #-1]
			»  ldrb w11, [x9, x0]
			» pIsAtStart:
			»  cmp w10, w11
			»  b.ne *fail
			break;
		case InstructionType::AssertStartOfLine:
			»  cmp p, pStart
			»  b.eq next
			»  ldurb w0, [p, #-1]
			»  cmp w0, #'\n'
			»  b.ne *fail
			» next:
			break;
		case InstructionType::AssertEndOfLine:
			»  cmp p, pEnd
			»  b.eq next
			»  ldrb w0, [p]
			»  cmp w0, #'\n'
			»  b.ne *fail
			» next:
			break;
		case InstructionType::AssertStartOfSearch:
			» cmp p, pSearchStart
			» b.ne *fail
			break;
		case InstructionType::AssertRecurseValue:
			» cmp recurseValue, #{instruction.data}
			» b.ne *fail
			break;
		case InstructionType::Byte:
			{
				int numberOfConsecutiveByteBitMaskInstructions =
					1 + patternData.CountSingleReferenceInstructions(pc+1,
																	 InstructionType::Byte,
																	 numberOfInstructions);

				int stride = 8;
				int offset = 0;
				while(stride)
				{
					while(offset < (numberOfConsecutiveByteBitMaskInstructions & -stride))
					{
						switch(stride)
						{
						case 8:
							» ldr x0, [p], #8
							» movz x10, #{patternData[pc+offset].data
							»             + 256*patternData[pc+offset+1].data}
							» movk x10, #{patternData[pc+offset+2].data
							»             + 256*patternData[pc+offset+3].data}, lsl #16
							» movk x10, #{patternData[pc+offset+4].data
							»             + 256*patternData[pc+offset+5].data}, lsl #32
							» movk x10, #{patternData[pc+offset+6].data
							»             + 256*patternData[pc+offset+7].data}, lsl #48
							» cmp x0, x10
							» b.ne *fail
							break;
						case 4:
							» ldr w0, [p], #4
							» movz w10, #{patternData[pc+offset].data
							»             + 256*patternData[pc+offset+1].data}
							» movk w10, #{patternData[pc+offset+2].data
							»             + 256*patternData[pc+offset+3].data}, lsl #16
							» cmp w0, w10
							» b.ne *fail
							break;
						case 2:
							» ldrh w0, [p], #2
							» movz w10, #{patternData[pc+offset].data
							»             + 256*patternData[pc+offset+1].data}
							» cmp w0, w10
							» b.ne *fail
							break;
						case 1:
							» ldrb w0, [p], #1
							» cmp w0, #{patternData[pc+offset].data}
							» b.ne *fail
							break;
						}
						
						offset += stride;
					}
					stride >>= 1;
				}
				» advanceBitStateIfNecessary numberOfConsecutiveByteBitMaskInstructions
				pc += numberOfConsecutiveByteBitMaskInstructions-1;
				
			}
			break;
		case InstructionType::ByteEitherOf2:
			» ldrb w0, [p], #1
			» cmp w0, #{instruction.data & 0xff}
		    » movz w9, #{instruction.data >> 8}
			» ccmp w0, w9, #4, ne
			» b.ne *fail
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::ByteEitherOf3:
			» ldrb w0, [p], #1
			» cmp w0, #{instruction.data & 0xff}
			» movz w9, #{(instruction.data >> 8) & 0xff}
			» ccmp w0, w9, #4, ne
			» movz w10, #{instruction.data >> 16}
			» ccmp w0, w10, #4, ne
			» b.ne *fail
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::ByteRange:
			{
				unsigned char low = instruction.data & 0xff;
				unsigned char high = (instruction.data >> 8) & 0xff;

				» ldrb w0, [p], #1
				» sub w0, w0, #{low}
				» cmp w0, #{high-low}
				» b.hi *fail
				if(type == PatternProcessorType::BitState)
				{
					» add pBitState, pBitState, #{context.numberOfBitStateInstructions / 8}
				}
			}
			break;
		case InstructionType::ByteBitMask:
			{
				» adr x9, {pc+0x10000}f
				
				int numberOfConsecutiveByteBitMaskInstructions =
					1 + patternData.CountSingleReferenceInstructions(pc+1,
																	 InstructionType::ByteBitMask,
																	 instruction.data,
																	 numberOfInstructions);

				int stride = 8;
				int offset = 0;
				while(stride)
				{
					for(;offset < (numberOfConsecutiveByteBitMaskInstructions & -stride); offset += stride)
					{
						switch(stride)
						{
						case 8:
							» ldr x10, [p], #8
							break;
						case 4:
							» ldr w10, [p], #4
							break;
						case 2:
							» ldrh w10, [p], #2
							break;
						case 1:
							» ldrb w0, [p], #1
							» ldrb w0, [x9, x0]
							» cbz w0, *fail
							continue;
						}
						
						for(int i = 0; i < stride; ++i)
						{
							» ubfx x0, x10, #{i*8}, #8
							» ldrb w0, [x9, x0]
							» cbz w0, *fail
						}
					}
					stride >>= 1;
				}
				» advanceBitStateIfNecessary numberOfConsecutiveByteBitMaskInstructions
				pc += numberOfConsecutiveByteBitMaskInstructions-1;
			}
			break;
		case InstructionType::ByteJumpTable:
			{
				const ByteCodeJumpTableData* data = patternData.GetData<ByteCodeJumpTableData>(instruction.data);
				if(context.hasByteJumpToByteJump
				   && patternData.HasLookupTableTarget(*data)
				   && type != PatternProcessorType::BitState)
				{
					»  adr x9, {0x10000+pc}f
					»  cmp p, pEnd
					»  b.hs fail
					» 1:
					»  ldrb w0, [p], #1
					»  ldr x9, [x9, w0, uxtw #3]
					»  tst x9, #(jumpTableAlignment-1)
					»  b.ne 1f
					»  cmp p, pEnd
					»  b.lo 1b
					» fail:
					»  mov x0, #0
					»  ret
					» 1:
					»  br x9
				}
				else
				{
					» adr x9, {0x10000+pc}f
					» cmp p, pEnd
					» b.hs *fail
					» ldrb w0, [p], #1
					» ldr x9, [x9, w0, uxtw #3]
					» advanceBitStateIfNecessary 1
					» br x9
				}
			}
			break;
		case InstructionType::ByteJumpMask:
			{
				const ByteCodeJumpMaskData* data = patternData.GetData<ByteCodeJumpMaskData>(instruction.data);

				» adr x9, {0x10000+pc}f
				» cmp p, pEnd
				» b.hs *fail
				» ldrb w0, [p], #1
				» ldrb w0, [x9, x0]
				» advanceBitStateIfNecessary 1
				» cbz w0, {data->pcData[0]}bf

				if(data->pcData[1] != pc+1)
				{
					» b {data->pcData[1]}bf
				}
			}
			break;
		case InstructionType::ByteJumpRange:
			{
				const ByteCodeJumpRangeData* jumpRangeData = patternData.GetData<ByteCodeJumpRangeData>(instruction.data);

				» cmp p, pEnd
				» b.hs *fail
				» ldrb w0, [p], #1
				» advanceBitStateIfNecessary 1

				if(jumpRangeData->range.GetSize() == 0)
				{
					» cmp w0, #{jumpRangeData->range.min}
					» b.ne {jumpRangeData->pcData[0]}bf
				}
				else
				{
					» sub w0, w0, #{jumpRangeData->range.min}
					» cmp w0, #{jumpRangeData->range.GetSize()}
					» b.hi {jumpRangeData->pcData[0]}bf
				}

				if(jumpRangeData->pcData[1] != pc+1)
				{
					» b {jumpRangeData->pcData[1]}bf
				}
			}
			break;
		case InstructionType::ByteNot:
			» ldrb w0, [p], #1
			» cmp w0, #{instruction.data}
			» b.eq *fail
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::ByteNotEitherOf2:
			» ldrb w0, [p], #1
			» cmp w0, #{instruction.data & 0xff}
		    » movz w9, #{instruction.data >> 8}
			» ccmp w0, w9, #4, ne
			» b.eq *fail
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::ByteNotEitherOf3:
			» ldrb w0, [p], #1
			» cmp w0, #{instruction.data & 0xff}
			» movz w9, #{(instruction.data >> 8) & 0xff}
			» ccmp w0, w9, #4, ne
			» movz w10, #{instruction.data >> 16}
			» ccmp w0, w10, #4, ne
			» b.eq *fail
			» advanceBitStateIfNecessary 1
			break;
		case InstructionType::ByteNotRange:
			{
				unsigned char low = instruction.data & 0xff;
				unsigned char high = (instruction.data >> 8) & 0xff;

				» ldrb w0, [p], #1
				» sub w0, w0, #{low}
				» cmp w0, #{high-low}
				» b.ls *fail
				» advanceBitStateIfNecessary 1
			}
			break;
		case InstructionType::FindByte:
			{
				context.EmitCallToSearch(0,
										 instruction.data & 0xff,
										 (void*) &PatternProcessor::FindByte);
				» add p, p, #1
				» advanceBitStateIfNecessary 1
				
				if((instruction.data >> 8) != pc+1)
				{
					» b {instruction.data >> 8}bf
				}
			}
			break;
		case InstructionType::SearchByte:
			{
				context.EmitCallToSearch(instruction.data >> 8,
										 instruction.data & 0xff,
										 (void*) &PatternProcessor::FindByte);
			}
			break;
		case InstructionType::SearchByteEitherOf2:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf2);
			}
			break;
		case InstructionType::SearchByteEitherOf3:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf3);
			}
			break;
		case InstructionType::SearchByteEitherOf4:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf4);
			}
			break;
		case InstructionType::SearchByteEitherOf5:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf5);
			}
			break;
		case InstructionType::SearchByteEitherOf6:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf6);
			}
			break;
		case InstructionType::SearchByteEitherOf7:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf7);
			}
			break;
		case InstructionType::SearchByteEitherOf8:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteEitherOf8);
			}
			break;
		case InstructionType::SearchBytePair:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindBytePair);
			}
			break;
		case InstructionType::SearchBytePair2:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindBytePair2);
			}
			break;
		case InstructionType::SearchBytePair3:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindBytePair3);
			}
			break;
		case InstructionType::SearchBytePair4:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindBytePair4);
			}
			break;
		case InstructionType::SearchByteRange:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindByteRange);
			}
			break;
		case InstructionType::SearchByteRangePair:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetFourBytes(),
										 (void*) &PatternProcessor::FindByteRangePair);
			}
			break;
		case InstructionType::SearchByteTriplet:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteTriplet);
			}
			break;
		case InstructionType::SearchByteTriplet2:
			{
				const ByteCodeSearchByteData* data = patternData.GetData<ByteCodeSearchByteData>(instruction.data);
				context.EmitCallToSearch(data->offset,
										 data->GetAllBytes(),
										 (void*) &PatternProcessor::FindByteTriplet2);
			}
			break;
		case InstructionType::SearchBoyerMoore:
			{
				const ByteCodeSearchData* searchData = patternData.GetData<ByteCodeSearchData>(instruction.data);

				if(type == PatternProcessorType::BitState)
				{
					» mov x10, p
				}
				
				»  adr x11, {0x10000+pc}f
				»  add p, p, #{searchData->length}
				» repeat:
				»  cmp p, pEnd
				»  b.hs *fail
				»  ldrb w0, [p]
				»  ldr w0, [x11, x0, lsl #2]
				»  add p, p, x0
				»  cbnz w0, repeat
				»  sub p, p, #{searchData->length}
				
				if(type == PatternProcessorType::BitState)
				{
					» sub x0, p, x10
					
					if(BitUtility::IsPowerOf2(context.numberOfBitStateInstructions))
					{
						» add pBitState, pBitState, x0, lsl #{__builtin_ctz(context.numberOfBitStateInstructions/8)}
					}
					else
					{
						» mov x11, #{context.numberOfBitStateInstructions/8}
						» madd pBitState, x0, x11, pBitState
					}
				}
			}
			break;
		case InstructionType::SearchShiftOr:
			{
				if(type == PatternProcessorType::BitState)
				{
					» str p, [sp, #-16]!
				}

				»   mov x0, x1
				»   adr x1, {0x10000+pc}f // searchData
				»   stp pEnd, lr, [sp, #-16]!
				» .if delta26x4{&PatternProcessor::FindShiftOr}
				»   bl {&PatternProcessor::FindShiftOr}
				» .else
				»   mov64 x9, &PatternProcessor::FindShiftOr
				»   blr x9
				» .endif
				»   ldp pEnd, lr, [sp], #16
				»   mov p, x0
				
				if(type == PatternProcessorType::BitState)
				{
					» ldr x10, [sp], #16
					» cbz x0, *fail
					» sub x0, p, x10
					
					if(BitUtility::IsPowerOf2(context.numberOfBitStateInstructions))
					{
						» add pBitState, pBitState, x0, lsl #{__builtin_ctz(context.numberOfBitStateInstructions/8)}
					}
					else
					{
						» mov x11, #{context.numberOfBitStateInstructions/8}
						» madd pBitState, x0, x11, pBitState
					}
					» b {pc+1}f
				}
				else
				{
					»   cbnz x0, {pc+1}f
					»   mov x0, #0
					»   ret
				}
				
				» .align 8
				» {0x10000+pc}:
				
				const ByteCodeSearchData* searchData = patternData.GetData<ByteCodeSearchData>(instruction.data);
				assembler.AppendData(searchData, sizeof(ByteCodeSearchData));
			}
			break;
		case InstructionType::PropagateBackwards:
			»   cbz captures, {pc+1}f
			»   adr x9, {0x10000+pc}f
				
			if(type == PatternProcessorType::BitState)
			{
				» mov x10, p
			}
				
			» repeat:
			»   ldrb w0, [p, #-1]!
			»   ldrb w0, [x9, x0]
			»   cbnz w0, repeat
			»   add p, p, #1
				
			if(type == PatternProcessorType::BitState)
			{
				» sub x0, x10, p
				
				if(BitUtility::IsPowerOf2(context.numberOfBitStateInstructions))
				{
					» sub pBitState, pBitState, x0, lsl #{__builtin_ctz(context.numberOfBitStateInstructions/8)}
				}
				else
				{
					» mov x11, #{context.numberOfBitStateInstructions/8}
					» msub pBitState, x0, x11, pBitState
				}
			}
			break;
		case InstructionType::DispatchTable:
			{
				const ByteCodeJumpTableData* data = patternData.GetData<ByteCodeJumpTableData>(instruction.data);

				» adr x9, {0x10000+pc}f
				» cmp p, pEnd
				» b.hs {data->pcData[0]}bf
				» ldrb w0, [p]
				» ldr x9, [x9, w0, uxtw #3]
				» br x9
			}
			break;
		case InstructionType::DispatchMask:
			{
				const ByteCodeJumpMaskData* data = patternData.GetData<ByteCodeJumpMaskData>(instruction.data);

				» adr x9, {0x10000+pc}f
				» cmp p, pEnd
				» b.hs {data->pcData[0]}bf
				» ldrb w0, [p]
				» ldrb w0, [x9, x0]
				» cbz w0, {data->pcData[0]}bf
				
				if(data->pcData[1] != pc+1)
				{
					» b {data->pcData[1]}bf
				}
			}
			break;
		case InstructionType::DispatchRange:
			{
				const ByteCodeJumpRangeData* jumpRangeData = patternData.GetData<ByteCodeJumpRangeData>(instruction.data);

				» cmp p, pEnd
				» b.hs {jumpRangeData->pcData[0]}bf
				» ldrb w0, [p]
				
				if(jumpRangeData->range.GetSize() == 0)
				{
					» cmp w0, #{jumpRangeData->range.min}
					
					if(jumpRangeData->pcData[0] == pc + 1)
					{
						» b.eq {jumpRangeData->pcData[1]}bf
					}
					else
					{
						» b.ne {jumpRangeData->pcData[0]}bf
						if(jumpRangeData->pcData[1] != pc + 1)
						{
							» b {jumpRangeData->pcData[1]}bf
						}
					}
				}
				else
				{
					» sub w0, w0, #{jumpRangeData->range.min}
					» cmp w0, #{jumpRangeData->range.GetSize()}
					
					if(jumpRangeData->pcData[0] == pc + 1)
					{
						» b.ls {jumpRangeData->pcData[1]}bf
					}
					else
					{
						» b.hi {jumpRangeData->pcData[0]}bf

						if(jumpRangeData->pcData[1] != pc+1)
						{
							» b {jumpRangeData->pcData[1]}bf
						}
					}
				}
			}
			break;
		case InstructionType::BackReference:
			{
				uint32_t index = instruction.data*2;
				»  ldp x0, x9, [captures, #{index*8}]
				»  subs x9, x9, x0				// x9 = length
				»  add x11, p, x9
				»  ccmp x11, pEnd, #2, hs
				»  b.hi *fail
				»  stp pEnd, lr, [sp, #-32]!
				»  str x11, [sp, #16]
				»  mov x2, x9
				» .if delta26x4{memcmp}
				»   bl {memcmp}
				» .else
				»   mov64 x10, memcmp
				»   blr x10
				» .endif
				»  ldr x1, [sp, #16]
				»  ldp pEnd, lr, [sp], #32
				»  cbnz x0, *fail
			}
			break;
		case InstructionType::Jump:
			» b {instruction.data}bf
			break;
		case InstructionType::Match:
			if(!header->IsFixedLength())
			{
				if(header->flags.matchRequiresEndOfInput)
				{
					» cmp p, pEnd
					» csel x0, p, xzr, eq
					» ret
				}
				else
				{
					// if(p == pEnd || isPartialMatch
					» cmp isPartialMatch, #0
					» ccmp p, pEnd, #4, eq
					» csel x0, p, xzr, eq
					» ret
				}
			}
			else
			{
				» mov x0, x1
				» ret
			}
			break;
		case InstructionType::Save:
		case InstructionType::SaveNoRecurse:
			{
				int32_t saveOffset = instruction.data >> 8;
				int32_t saveIndex = (instruction.data & 0xff) * 8;

				if(!header->flags.alwaysRequiresCaptures
				   && !(pc > 0 && patternData[pc-1].IsSave()))
				{
					» cbz captures, *1f
				}
				
				if(type == PatternProcessorType::OnePass
				   || instruction.type == InstructionType::SaveNoRecurse)
				{
					if(saveOffset == 0)
					{
						» str p, [captures, #{saveIndex}]
					}
					else if(pc > 0
							&& patternData[pc-1].IsSave()
							&& (patternData[pc-1].data >> 8) == saveOffset)
					{
						» str x0, [captures, #{saveIndex}]
					}
					else
					{
						» sub x0, p, #{saveOffset}
						» str x0, [captures, #{saveIndex}]
					}
				}
				else
				{
					»  sub x0, p, #{saveOffset}
					»  ldr x9, [captures, #{saveIndex}]
					»  str x0, [captures, #{saveIndex}]
					»  stp p, x9, [sp, #-32]!
					»  stp lr, pBitState, [sp, #16]
					»  bl next
					»  ldp lr, pBitState, [sp, #16]
					»  ldp p, x9, [sp], #32
					»  cbnz x0, done
					»  str x9, [captures, #{saveIndex}]
					» done:
					»  ret
					» next:
				}
				
				if(!header->flags.alwaysRequiresCaptures
				   && !patternData[pc+1].IsSave())
				{
					» *1:
				}
			}
			break;
		case InstructionType::Fail:
			» mov x0, #0
			» ret
			break;
		case InstructionType::Success:
			» mov x0, x1
			» ret
			break;
		case InstructionType::Call:
			{
				const ByteCodeCallData* callData = patternData.GetData<ByteCodeCallData>(instruction.data);
				» stp p, lr, [sp, #-16]!
				» bl {callData->callIndex}bf
				» ldp p, lr, [sp], #16
				» cbz x0, {callData->falseIndex}bf
				
				if(callData->trueIndex != pc + 1)
				{
					» b {callData->trueIndex}bf
				}
			}
			break;
		case InstructionType::Possess:
			{
				const ByteCodeCallData* callData = patternData.GetData<ByteCodeCallData>(instruction.data);
				» stp p, lr, [sp, #-16]!
				» bl {callData->callIndex}bf
				» ldp p, lr, [sp], #16
				» cbz x0, {callData->falseIndex}bf
				» mov p, x0

				if(callData->trueIndex != pc + 1)
				{
					» b {callData->trueIndex}bf
				}
			}
			break;
		case InstructionType::Recurse:
			{
				int value = instruction.data & 0xff;
				int recursePc = instruction.data >> 8;
				
				»  stp recurseValue, lr, [sp, #-16]!
				»  mov recurseValue, #{value}
				»  cbz captures, *1f
				
				for(int i = 0; i < header->numberOfCaptures; ++i)
				{
					» ldp x9, x10, [captures, #{16*i}]
					» stp x9, x10, [sp, #-16]!
				}
				
				» *1:
				»  bl {recursePc}bf
				»  cbz captures, *1f
				
				for(int i = header->numberOfCaptures-1; i >= 0; --i)
				{
					» ldp x9, x10, [sp], #16
					» stp x9, x10, [captures, #{16*i}]
				}

				» *1:
				»  ldp recurseValue, lr, [sp], #16
				»  cbz x0, *fail
				»  mov p, x0
			}
			break;
		case InstructionType::ReturnIfRecurseValue:
			»  cmp recurseValue, #{instruction.data}
			»  b.ne next
			»  mov x0, p
			»  ret
			» next:
			break;
		case InstructionType::ProgressCheck:
			if(instruction.data < 4)
			{
				»  cmp reg64{PROGRESS_CHECK_BASE+instruction.data}, p
				»  b.hs fail
				»  stp reg64{PROGRESS_CHECK_BASE+instruction.data}, lr, [sp, #-16]!
				»  mov reg64{PROGRESS_CHECK_BASE+instruction.data}, p
				»  bl next
				»  ldp x9, lr, [sp], #16
				»  cbnz x0, done
				»  mov reg64{PROGRESS_CHECK_BASE+instruction.data}, x9
				» fail:
				»  mov x0, #0
				» done:
				»  ret
				» next:
			}
			else
			{
				»  ldr x9, [pProgressCheck, #{(instruction.data-4)*8}]
				»  cmp x9, p
				»  b.hs fail
				»  stp x9, lr, [sp, #-16]!
				»  str p, [pProgressCheck, #{(instruction.data-4)*8}]
				»  bl next
				»  ldp x9, lr, [sp], #16
				»  cbnz x0, done
				»  str x9, [pProgressCheck, #{(instruction.data-4)*8}]
				» fail:
				»  mov x0, #0
				» done:
				»  ret
				» next:
			}
			break;
		case InstructionType::Split:
			{
				const ByteCodeSplitData* split = patternData.GetData<ByteCodeSplitData>(instruction.data);
				uint32_t numberOfTargets = split->numberOfTargets;
				for(size_t i = 0; i < numberOfTargets-1; ++i)
				{
					if(type == PatternProcessorType::BitState)
					{
						» stp p, lr, [sp, #-32]!
						» str pBitState, [sp, #16]
						» bl {split->targetList[i]}bf
						» ldr pBitState, [sp, #16]
						» ldp p, lr, [sp], #32
						» cbnz x0, *done
					}
					else
					{
						» stp p, lr, [sp, #-16]!
						» bl {split->targetList[i]}bf
						» ldp p, lr, [sp], #16
						» cbnz x0, *done
					}
				}
				» b {split->targetList[numberOfTargets-1]}bf
			}
			break;
		case InstructionType::SplitNextN:
			if(type == PatternProcessorType::BitState)
			{
				»  stp p, lr, [sp, #-32]!
				»  str pBitState, [sp, #16]
				»  bl next
				»  ldr pBitState, [sp, #16]
				»  ldp p, lr, [sp], #32
				»  cbnz x0, *done
				»  b {instruction.data}bf
				» next:
			}
			else
			{
				»  stp p, lr, [sp, #-16]!
				»  bl next
				»  ldp p, lr, [sp], #16
				»  cbnz x0, *done
				»  b {instruction.data}bf
				» next:
			}
			break;
		case InstructionType::SplitNNext:
			if(type == PatternProcessorType::BitState)
			{
				» stp p, lr, [sp, #-32]!
				» str pBitState, [sp, #16]
				» bl {instruction.data}bf
				» ldr pBitState, [sp, #16]
				» ldp p, lr, [sp], #32
				» cbnz x0, *done
			}
			else
			{
				» stp p, lr, [sp, #-16]!
				» bl {instruction.data}bf
				» ldp p, lr, [sp], #16
				» cbnz x0, *done
			}
			break;
		case InstructionType::SplitNextMatchN:
			if(header->flags.matchRequiresEndOfInput)
			{
				» cmp p, pEnd
				» b.ne {instruction.data}bf
			}
			else
			{
				» cmp isPartialMatch, #0
				» ccmp p, pEnd, #4, eq
				» b.ne {instruction.data}bf
			}
			break;
		case InstructionType::SplitNMatchNext:
			if(header->flags.matchRequiresEndOfInput)
			{
				» cmp p, pEnd
				» b.eq {instruction.data}bf
			}
			else
			{
				» cmp isPartialMatch, #0
				» ccmp p, pEnd, #4, eq
				» b.eq {instruction.data}bf
			}
			break;
		case InstructionType::SplitMatch:
			if(header->flags.matchRequiresEndOfInput)
			{
				const uint32_t* splitData = patternData.GetData<uint32_t>(instruction.data);
				» cmp p, pEnd
				» b.eq {splitData[0]}bf
				» b {splitData[1]}bf
			}
			else
			{
				const uint32_t* splitData = patternData.GetData<uint32_t>(instruction.data);
				» cmp isPartialMatch, #0
				» ccmp p, pEnd, #4, eq
				» b.eq {splitData[0]}bf
				» b {splitData[1]}bf
			}
			break;
		default:
			» brk #{pc}
			break;
		}
	}
	
	if(context.hasByteJumpToByteJump)
	{
		» .align jumpTableAlignment
	}

	for(uint32_t pc = 0; pc < numberOfInstructions; ++pc)
	{
		ByteCodeInstruction instruction = patternData[pc];
		switch(instruction.type)
		{
		case InstructionType::ByteBitMask:
		case InstructionType::PropagateBackwards:
			{
				» {0x10000+pc}:
				uint8_t *data = (uint8_t*) assembler.AppendData(256);
				const StaticBitTable<256>& bitTable = *patternData.GetData<StaticBitTable<256>>(instruction.data);
				for(int c = 0; c < 256; ++c)
				{
					data[c] = bitTable[c];
				}

				if(instruction.type == InstructionType::ByteBitMask)
				{
					pc += patternData.CountSingleReferenceInstructions(pc+1,
																	   InstructionType::ByteBitMask,
																	   instruction.data);
				}
			}
			break;
		case InstructionType::ByteJumpMask:
		case InstructionType::DispatchMask:
			{
				const ByteCodeJumpMaskData* maskData = patternData.GetData<ByteCodeJumpMaskData>(instruction.data);

				» {0x10000+pc}:
				uint8_t *data = (uint8_t*) assembler.AppendData(256);
				for(int c = 0; c < 256; ++c)
				{
					data[c] = maskData->bitMask[c];
				}
			}
			break;
		case InstructionType::ByteJumpTable:
			{
				const ByteCodeJumpTableData* data = patternData.GetData<ByteCodeJumpTableData>(instruction.data);

				» {0x10000+pc}:
				for(int i = 0; i < 256; ++i)
				{
					uint32_t targetPc = data->pcData[data->jumpTable[i]];
					if(type == PatternProcessorType::BitState)
					{
						» .quad {targetPc}bf
					}
					else if(targetPc < header->numberOfInstructions
							&& patternData[targetPc].type == InstructionType::ByteJumpTable)
					{
						» .quad {0x10000+targetPc}bf
					}
					else
					{
						» .quad {targetPc}b
					}
				}
			}
			break;
		case InstructionType::DispatchTable:
			{
				const ByteCodeJumpTableData* data = patternData.GetData<ByteCodeJumpTableData>(instruction.data);

				» {0x10000+pc}:
				for(int i = 0; i < 256; ++i)
				{
					uint32_t targetPc = data->pcData[data->jumpTable[i]];
					» .quad {targetPc}b
				}
			}
			break;
		case InstructionType::SearchBoyerMoore:
			{
				const ByteCodeSearchData* searchData = patternData.GetData<ByteCodeSearchData>(instruction.data);

				» .align 8
				» {0x10000+pc}:
				assembler.AppendDataPointer(searchData->data, sizeof(searchData->data));
			}
		default:
			break;
		}
	}
	
	return (PatternProcessor*) assembler.Build();
}

//============================================================================

PatternProcessor* PatternProcessor::CreateOnePassProcessor(DataBlock&& dataBlock)
{
	return CreateArm64PatternProcessor(dataBlock.GetData(), dataBlock.GetCount(), PatternProcessorType::OnePass, 0);
}

PatternProcessor* PatternProcessor::CreateOnePassProcessor(const void* data, size_t length, bool makeCopy)
{
	return CreateArm64PatternProcessor(data, length, PatternProcessorType::OnePass, 0);
}

PatternProcessor* PatternProcessor::CreateBitStateProcessor(const void* data, size_t length)
{
	return CreateArm64PatternProcessor(data, length, PatternProcessorType::BitState, 0);
}

PatternProcessor* PatternProcessor::CreateBackTrackingProcessor(DataBlock&& dataBlock)
{
	return CreateArm64PatternProcessor(dataBlock.GetData(), dataBlock.GetCount(), PatternProcessorType::BackTracking, 0);
}

PatternProcessor* PatternProcessor::CreateBackTrackingProcessor(const void* data, size_t length, bool makeCopy)
{
	return CreateArm64PatternProcessor(data, length, PatternProcessorType::BackTracking, 0);
}

//============================================================================
#endif // PATTERN_USE_JIT && defined(JABI_ARM64_PCS)
//============================================================================
